{"noir_version":"1.0.0-beta.12+9a5b3695b42e391fa27c48e87b9bbb07523d664d","hash":"14758635293439170511","abi":{"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"},{"name":"y","type":{"kind":"field"},"visibility":"private"},{"name":"z","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/62QQQqAMAwErfigpEna5OZXLLb/f4JKLZbiTQdCQg7Dsm6qzOe46aHd670JAnOOPiPhBt6SCrCkoKgoKrtXoqys0ZJFMGTKWMSoQKU5Ry98A+f/XHBlW7o++i7cy3/kABypNGJMAQAA","debug_symbols":"lZDBCoMwDIbfJecenDIYvsoYUmuUQkhLbAdDfPdF0c0dPOyUJn/+r+SfoMM2D43nPoxQ3ydoxRP5oaHgbPKBdTrNBva2SYKoIzjo6opWkBPUnIkMPC3ldWmMltearKhaGEDutCqw94TLazZfd3FuLavLbXOXVXn5AK7/EKozwkM767z8XA2Fbs4LULxtCbck+szuEEx6xV3Zo4sSHHZZcMGtmn7wBg==","file_map":{"50":{"source":"// // This circuit proves:\n// // - The user has a valid array of user addresses and knows the corresponding roles.\n// // - The number of werewolves in the assignment is correct.\n// // - All roles are either a Villager (0) or a Werewolf (1).\n\n// fn main(\n//     user_addresses: [Field; N], // private: user addresses\n//     assigned_roles: [Field; N], // private: 0 (villager), 1 (werewolf)\n//     user_role_proofs: [Field; N], // private: user-specific salts for commitments\n\n//     user_addresses_hash: pub Field, // public: hash of all user addresses\n//     werewolf_count: pub Field, // public: number of werewolves\n// ) -> pub [Field; N] { // public: user-role commitments\n\n//     // The length of the arrays, N, is known at compile time and doesn't need\n//     // to be passed as an input. It can be derived from the array size.\n\n//     // 1. Constrain the hash of the user addresses to be correct.\n//     constrain(hash_poseidon(user_addresses) == user_addresses_hash);\n\n//     // 2. Initialize a counter for werewolves.\n//     let mut actual_werewolf_count = 0;\n//     let mut user_role_commitments: [Field; N] = [0; N];\n\n//     // 3. Iterate through each player, constraining their role and creating a commitment.\n//     for i in 0..N {\n//         // The loop body must be enclosed in curly braces.\n//         {\n//             // Constrain the role to be either 0 or 1.\n//             // We use an assert instead of a constraint, which is more\n//             // gas-efficient and is a common pattern for logical checks.\n//             assert(assigned_roles[i] == 0 || assigned_roles[i] == 1);\n\n//             // If the role is a werewolf (1), increment the counter.\n//             if assigned_roles[i] == 1 {\n//                 actual_werewolf_count += 1;\n//             }\n\n//             // Create a public commitment for each user and their role.\n//             user_role_commitments[i] = hash_poseidon([\n//                 user_addresses[i], assigned_roles[i], user_role_proofs[i]\n//             ]);\n//         }\n//     }\n\n//     // 4. Constrain the actual werewolf count to equal the public input.\n//     constrain(actual_werewolf_count == werewolf_count);\n\n//     // 5. Return the public commitments.\n//     return user_role_commitments;\n// }\n\n\nfn main(x: Field, y: Field, z: pub Field) {\n    assert(z == x*y);\n}","path":"/root/coding/zkforge/zkWerewolf/contracts/circuits/GameSetup/src/main.nr"}},"names":["main"],"brillig_names":[]}